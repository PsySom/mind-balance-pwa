import { useState, useEffect, useRef } from 'react';
import { useAuth } from '@/hooks/useAuth';
import { supabase } from '@/integrations/supabase/client';
import { aiDiarySessionsService } from '@/services/ai-diary-sessions.service';
import { toast } from 'sonner';
import type { RealtimeChannel } from '@supabase/supabase-js';
import { config } from '@/lib/config';

export interface ChatMessage {
  id: string;
  content: string;
  type: 'user' | 'ai' | 'system';
  timestamp: string;
  suggestions?: string[];
  emotions?: {
    primary: string;
    intensity: string;
    triggers: string[];
  };
  analysis?: {
    cognitive_distortions: string[];
    themes: string[];
    mood_score: number;
  };
}

type SessionStatus = 'loading' | 'active' | 'error';

export function useAIDiaryChat() {
  const { user, session } = useAuth();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [realtimeChannel, setRealtimeChannel] = useState<RealtimeChannel | null>(null);
  const [sessionStatus, setSessionStatus] = useState<SessionStatus>('loading');
  const fallbackTimeoutRef = useRef<NodeJS.Timeout>();

  // WELCOME MESSAGE
  const WELCOME_MESSAGE: ChatMessage = {
    id: 'welcome',
    content: '–ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π AI-–ø–æ–º–æ—â–Ω–∏–∫ –ø–æ –º–µ–Ω—Ç–∞–ª—å–Ω–æ–º—É –∑–¥–æ—Ä–æ–≤—å—é. –†–∞—Å—Å–∫–∞–∂–∏, —á—Ç–æ —É —Ç–µ–±—è –Ω–∞ –¥—É—à–µ?',
    type: 'system',
    timestamp: new Date().toISOString(),
    suggestions: [
      'üí≠ –†–∞—Å—Å–∫–∞–∂—É –æ —Å–≤–æ—ë–º –¥–Ω–µ',
      'üòî –ß—É–≤—Å—Ç–≤—É—é —Ç—Ä–µ–≤–æ–≥—É',
      'ü§î –•–æ—á—É —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è –≤ —Å–µ–±–µ',
      'üòä –ü–æ–¥–µ–ª—é—Å—å —Ä–∞–¥–æ—Å—Ç—å—é'
    ]
  };

  // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–ï–°–°–ò–ò
  useEffect(() => {
    const initSession = async () => {
      if (!user?.id) return;
      
      try {
        setSessionStatus('loading');
        
        const savedSessionId = localStorage.getItem('ai_diary_session_id');
        
        if (savedSessionId) {
          console.log('üîç Checking saved session:', savedSessionId);
          
          const isValid = await aiDiarySessionsService.validateSession(
            savedSessionId,
            user.id
          );
          
          if (isValid) {
            console.log('‚úÖ Session is valid, loading history');
            setSessionId(savedSessionId);
            await loadSessionHistory(savedSessionId);
          } else {
            console.log('‚ö†Ô∏è Session invalid, clearing');
            localStorage.removeItem('ai_diary_session_id');
            setMessages([WELCOME_MESSAGE]);
          }
        } else {
          console.log('üìù No saved session, showing welcome');
          setMessages([WELCOME_MESSAGE]);
        }
        
        setSessionStatus('active');
      } catch (error) {
        console.error('‚ùå Session init error:', error);
        setSessionStatus('error');
        setMessages([WELCOME_MESSAGE]);
        toast.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–µ—Å—Å–∏–∏');
      }
    };
    
    initSession();
  }, [user?.id]);

  // –ó–ê–ì–†–£–ó–ö–ê –ò–°–¢–û–†–ò–ò –°–ï–°–°–ò–ò
  const loadSessionHistory = async (sid: string) => {
    try {
      const history = await aiDiarySessionsService.getSessionMessages(sid);
      
      if (history.length === 0) {
        setMessages([WELCOME_MESSAGE]);
        return;
      }
      
      const chatMessages: ChatMessage[] = [];
      
      history.forEach((msg) => {
        // User message
        if (msg.message) {
          chatMessages.push({
            id: `${msg.id}-user`,
            content: msg.message,
            type: 'user',
            timestamp: msg.created_at
          });
        }
        
        // AI response
        if (msg.ai_response) {
          chatMessages.push({
            id: msg.id,
            content: msg.ai_response,
            type: 'ai',
            timestamp: msg.created_at,
            suggestions: msg.suggestions || [],
            emotions: msg.emotions,
            analysis: msg.analysis
          });
        }
      });
      
      setMessages(chatMessages);
      console.log('‚úÖ Loaded', chatMessages.length, 'messages');
      
    } catch (error) {
      console.error('‚ùå Load history error:', error);
      toast.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é');
      setMessages([WELCOME_MESSAGE]);
    }
  };

  // REALTIME –ü–û–î–ü–ò–°–ö–ê
  useEffect(() => {
    if (!sessionId || !supabase) return;
    
    console.log('üîÑ Setting up Realtime for session:', sessionId);
    
    if (realtimeChannel) {
      realtimeChannel.unsubscribe();
    }
    
    const channel = supabase
      .channel(`ai_diary_session:${sessionId}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'ai_diary_messages',
          filter: `session_id=eq.${sessionId}`
        },
        (payload) => {
          console.log('üì® Realtime event:', payload.eventType);
          
          const newMessage = payload.new as any;
          
          if (newMessage.message_type === 'ai') {
            handleNewAIMessage(newMessage);
          }
        }
      )
      .subscribe((status) => {
        console.log('Realtime status:', status);
        if (status === 'SUBSCRIBED') {
          console.log('‚úÖ Subscribed to Realtime');
        } else if (status === 'CHANNEL_ERROR') {
          console.error('‚ùå Realtime error');
        }
      });
    
    setRealtimeChannel(channel);
    
    return () => {
      console.log('üîå Unsubscribing from Realtime');
      channel.unsubscribe();
    };
  }, [sessionId]);

  // –û–ë–†–ê–ë–û–¢–ö–ê –ù–û–í–û–ì–û AI –°–û–û–ë–©–ï–ù–ò–Ø –ò–ó REALTIME
  const handleNewAIMessage = (dbMessage: any) => {
    // –û—á–∏—â–∞–µ–º fallback —Ç–∞–π–º–µ—Ä
    if (fallbackTimeoutRef.current) {
      clearTimeout(fallbackTimeoutRef.current);
    }
    
    setMessages((prev) => {
      const exists = prev.some((m) => m.id === dbMessage.id);
      if (exists) {
        console.log('‚ö†Ô∏è Message already exists:', dbMessage.id);
        return prev;
      }
      
      const aiMessage: ChatMessage = {
        id: dbMessage.id,
        content: dbMessage.ai_response,
        type: 'ai',
        timestamp: dbMessage.created_at,
        suggestions: dbMessage.suggestions || [],
        emotions: dbMessage.emotions,
        analysis: dbMessage.analysis
      };
      
      console.log('‚úÖ Adding AI message from Realtime:', aiMessage.id);
      
      // Typing effect –¥–ª—è –¥–ª–∏–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
      if (aiMessage.content.length > 100) {
        setIsTyping(true);
        typeMessage(aiMessage).then(() => setIsTyping(false));
        return prev;
      }
      
      return [...prev, aiMessage];
    });
  };

  // TYPING EFFECT
  const typeMessage = async (message: ChatMessage) => {
    const words = message.content.split(' ');
    
    if (words.length < 20) {
      setMessages((prev) => [...prev, message]);
      return;
    }
    
    let displayedContent = '';
    const tempMessage = { ...message, content: '' };
    
    setMessages((prev) => [...prev, tempMessage]);
    
    for (let i = 0; i < words.length; i++) {
      displayedContent += (i === 0 ? '' : ' ') + words[i];
      
      await new Promise((resolve) => setTimeout(resolve, 50));
      
      setMessages((prev) =>
        prev.map((m) =>
          m.id === tempMessage.id ? { ...m, content: displayedContent } : m
        )
      );
    }
  };

  // –û–¢–ü–†–ê–í–ö–ê –°–û–û–ë–©–ï–ù–ò–Ø
  const sendMessage = async (messageText: string) => {
    if (!messageText.trim() || isLoading || !session || !user) return;
    
    const tempId = `temp-${Date.now()}`;
    
    try {
      setIsLoading(true);
      
      // 1. Optimistic UI
      const userMessage: ChatMessage = {
        id: tempId,
        content: messageText.trim(),
        type: 'user',
        timestamp: new Date().toISOString()
      };
      setMessages((prev) => [...prev, userMessage]);
      
      // 2. –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ webhook
      console.log('üì§ Sending to webhook:', {
        url: config.webhooks.diary,
        user_id: user.id,
        session_id: sessionId || 'NEW',
        message_preview: messageText.substring(0, 30) + '...'
      });
      
      const response = await fetch(`${config.webhooks.diary}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          userJwt: session.access_token,
          user_id: user.id,
          message: messageText.trim(),
          session_id: sessionId,
          locale: 'ru'
        })
      });
      
      console.log('üì• Response status:', response.status, response.statusText);
      
      // –î–µ—Ç–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ HTTP –æ—à–∏–±–æ–∫
      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Webhook HTTP error:', {
          status: response.status,
          statusText: response.statusText,
          body: errorText.substring(0, 200)
        });
        
        if (response.status === 500) {
          throw new Error('–°–µ—Ä–≤–µ—Ä –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
        } else if (response.status === 401 || response.status === 403) {
          throw new Error('–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏. –ü–µ—Ä–µ–∑–∞–π–¥–∏—Ç–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.');
        } else if (response.status === 400) {
          throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ.');
        }
        
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
      const responseText = await response.text();
      console.log('üì• Raw response:', {
        length: responseText.length,
        preview: responseText.substring(0, 200)
      });
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ—Ç–≤–µ—Ç –Ω–µ –ø—É—Å—Ç–æ–π
      if (!responseText || responseText.trim().length === 0) {
        console.error('‚ùå Empty response from webhook');
        throw new Error('–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ n8n workflow.');
      }
      
      // –ü–∞—Ä—Å–∏–º JSON
      let data: any;
      try {
        data = JSON.parse(responseText);
      } catch (parseError) {
        console.error('‚ùå JSON parse error:', parseError);
        console.error('Response text:', responseText);
        throw new Error('–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö (–Ω–µ JSON)');
      }
      
      console.log('‚úÖ Parsed webhook response:', {
        success: data.success,
        session_id: data.data?.session_id,
        has_ai_response: !!data.data?.ai_response,
        ai_response_length: data.data?.ai_response?.length || 0,
        suggestions_count: data.data?.suggestions?.length || 0
      });
      
      if (!data.success) {
        throw new Error(data.message || 'API –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É');
      }
      
      if (!data.data || !data.data.ai_response) {
        console.error('‚ùå Missing ai_response in data:', data);
        throw new Error('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –æ—Ç–≤–µ—Ç AI –≤ –¥–∞–Ω–Ω—ã—Ö');
      }
      
      const responseData = data.data;
      
      // 3. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ session_id –¥–ª—è –Ω–æ–≤–æ–π —Å–µ—Å—Å–∏–∏
      if (responseData.session_id && responseData.session_id !== sessionId) {
        console.log('üÜï New session created:', responseData.session_id);
        setSessionId(responseData.session_id);
        localStorage.setItem('ai_diary_session_id', responseData.session_id);
      }
      
      // 4. –ó–∞–º–µ–Ω—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π ID –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π
      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === tempId
            ? { ...msg, id: `${responseData.saved_entry_id}-user` }
            : msg
        )
      );
      
      // 5. Fallback —á–µ—Ä–µ–∑ 30 —Å–µ–∫—É–Ω–¥ –µ—Å–ª–∏ Realtime –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
      if (fallbackTimeoutRef.current) {
        clearTimeout(fallbackTimeoutRef.current);
      }
      
      fallbackTimeoutRef.current = setTimeout(() => {
        setMessages((prev) => {
          const hasAIResponse = prev.some(
            (m) => m.type === 'ai' && m.timestamp > userMessage.timestamp
          );
          
          if (!hasAIResponse) {
            console.warn('‚è∞ Realtime timeout - using fallback');
            const aiMessage: ChatMessage = {
              id: responseData.saved_entry_id,
              content: responseData.ai_response,
              type: 'ai',
              timestamp: responseData.timestamp,
              suggestions: responseData.suggestions,
              emotions: responseData.emotions,
              analysis: responseData.analysis
            };
            return [...prev, aiMessage];
          }
          
          return prev;
        });
        setIsTyping(false);
      }, 30000);
      
    } catch (error: any) {
      console.error('‚ùå Send message error:', error);
      
      if (error.message.includes('Failed to fetch')) {
        toast.error('–ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É');
      } else if (error.message.includes('500')) {
        toast.error('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ');
      } else if (error.message.includes('–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏')) {
        toast.error(error.message);
      } else {
        toast.error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ');
      }
      
      setMessages((prev) => prev.filter((m) => m.id !== tempId));
    } finally {
      setIsLoading(false);
    }
  };

  // –ù–û–í–ê–Ø –°–ï–°–°–ò–Ø
  const startNewSession = async () => {
    try {
      if (realtimeChannel) {
        realtimeChannel.unsubscribe();
      }
      
      if (sessionId) {
        await aiDiarySessionsService.endSession(sessionId);
      }
      
      localStorage.removeItem('ai_diary_session_id');
      setSessionId(null);
      setMessages([WELCOME_MESSAGE]);
      
      toast.success('–ù–æ–≤–∞—è —Å–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞');
    } catch (error) {
      console.error('‚ùå Start new session error:', error);
      toast.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é');
    }
  };

  // –ó–ê–í–ï–†–®–ï–ù–ò–ï –°–ï–°–°–ò–ò
  const endSession = async () => {
    if (!sessionId) return;
    
    try {
      await aiDiarySessionsService.endSession(sessionId);
      
      if (realtimeChannel) {
        realtimeChannel.unsubscribe();
      }
      
      localStorage.removeItem('ai_diary_session_id');
      setSessionId(null);
      setMessages([WELCOME_MESSAGE]);
      
      toast.success('–°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
    } catch (error) {
      console.error('‚ùå End session error:', error);
      toast.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å —Å–µ—Å—Å–∏—é');
    }
  };

  // –ö–õ–ò–ö –ü–û SUGGESTION
  const handleSuggestionClick = (suggestion: string) => {
    sendMessage(suggestion);
  };

  // Cleanup
  useEffect(() => {
    return () => {
      if (fallbackTimeoutRef.current) {
        clearTimeout(fallbackTimeoutRef.current);
      }
    };
  }, []);

  return {
    messages,
    sessionId,
    isLoading,
    isTyping,
    sessionStatus,
    realtimeChannel,
    sendMessage,
    startNewSession,
    endSession,
    handleSuggestionClick
  };
}
